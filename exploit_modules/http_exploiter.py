import requests
from bs4 import BeautifulSoup # Para parsear HTML, pode ser útil para XSS básico ou encontrar formulários

class HTTPExploiter:
    def __init__(self, target_host, port=80, protocol='http'):
        self.target_host = target_host
        self.port = port
        self.protocol = protocol
        self.base_url = f"{self.protocol}://{self.target_host}:{self.port}"

    def check_common_vulnerabilities(self):
        """
        Verifica algumas vulnerabilidades web comuns (simulação/básico).
        Em um cenário real, usaria ferramentas como OWASP ZAP, Burp Suite, sqlmap, nikto etc.
        """
        print(f"[HTTPExploiter] Iniciando verificação de vulnerabilidades web comuns em {self.base_url}")
        
        vulnerabilities_found = []

        # 1. Tentativa de detectar XSS refletido básico (simulação)
        # Tenta injetar um script simples em um parâmetro de URL
        test_payload = "<script>alert(\"XSS_Test_ManusAI\")</script>"
        # Vamos simular uma URL com um parâmetro comum
        test_url_xss = f"{self.base_url}/search?query={test_payload}"
        try:
            print(f"[HTTPExploiter] Testando XSS refletido básico em: {test_url_xss}")
            # Em um teste real, você faria a requisição e analisaria a resposta
            # para ver se o payload é refletido sem sanitização.
            # Aqui, apenas simulamos a lógica.
            # response = requests.get(test_url_xss, timeout=5)
            # if test_payload in response.text:
            #     print(f"[HTTPExploiter] Potencial XSS Refletido encontrado em {test_url_xss}")
            #     vulnerabilities_found.append({"type": "XSS Refletido (Simulado)", "url": test_url_xss, "payload": test_payload})
            print("[HTTPExploiter] Simulação de teste XSS: Nenhuma vulnerabilidade XSS óbvia encontrada nesta simulação.")
        except requests.exceptions.RequestException as e:
            print(f"[HTTPExploiter] Erro ao tentar testar XSS em {test_url_xss}: {e}")

        # 2. Verificar cabeçalhos de segurança comuns (simulação)
        print(f"[HTTPExploiter] Verificando cabeçalhos de segurança em {self.base_url}")
        try:
            response = requests.get(self.base_url, timeout=5)
            headers = response.headers
            # Exemplo: Verificar X-Frame-Options
            if not headers.get("X-Frame-Options"):
                print("[HTTPExploiter] Cabeçalho X-Frame-Options ausente. Potencial risco de Clickjacking.")
                vulnerabilities_found.append({"type": "Missing X-Frame-Options", "url": self.base_url, "severity": "Medium"})
            else:
                # Corrigido: Usar aspas simples dentro da f-string ou escapar as aspas duplas.
                # Optou-se por aspas simples para clareza.
                print(f"[HTTPExploiter] X-Frame-Options: {headers.get('X-Frame-Options')}")
            # Outros cabeçalhos poderiam ser verificados aqui (CSP, HSTS, etc.)
        except requests.exceptions.RequestException as e:
            print(f"[HTTPExploiter] Erro ao verificar cabeçalhos em {self.base_url}: {e}")

        # 3. Procurar por arquivos comuns (robots.txt, sitemap.xml) (simulação)
        common_files = ["robots.txt", "sitemap.xml"]
        for f_name in common_files:
            file_url = f"{self.base_url}/{f_name}"
            try:
                print(f"[HTTPExploiter] Verificando existência de {file_url}")
                # response_file = requests.get(file_url, timeout=3)
                # if response_file.status_code == 200:
                #     print(f"[HTTPExploiter] Arquivo {f_name} encontrado em {file_url}")
                #     vulnerabilities_found.append({"type": "Informational", "message": f"Arquivo {f_name} encontrado", "url": file_url})
                print(f"[HTTPExploiter] Simulação: Verificação de {f_name} concluída.")
            except requests.exceptions.RequestException as e:
                print(f"[HTTPExploiter] Erro ao verificar {file_url}: {e}")

        if not vulnerabilities_found:
            print(f"[HTTPExploiter] Nenhuma vulnerabilidade web comum óbvia encontrada em {self.base_url} nesta simulação.")
        
        return vulnerabilities_found

if __name__ == "__main__":
    # Exemplo de uso
    # Para testar, você pode rodar um servidor HTTP local simples.
    # Ex: python -m http.server 8000
    # E então usar target_host="localhost", port=8000
    
    # Teste com um site público (cuidado para não ser intrusivo)
    # http_exploiter = HTTPExploiter(target_host="scanme.nmap.org") # scanme.nmap.org é HTTP
    # http_exploiter_ssl = HTTPExploiter(target_host="nmap.org", port=443, protocol="https") # nmap.org é HTTPS

    print("Criando um servidor HTTP local simples para teste: python3 -m http.server 8080 &")
    # Este comando abaixo é apenas para demonstração, não vai funcionar diretamente aqui.
    # Idealmente, o usuário rodaria isso em um terminal separado.
    # import subprocess
    # import time
    # subprocess.Popen(["python3", "-m", "http.server", "8080"])
    # time.sleep(2) # Dar um tempo para o servidor iniciar

    print("\n--- Testando HTTPExploiter com servidor local simulado (localhost:8080) ---")
    print("Por favor, inicie um servidor HTTP local na porta 8080 em outro terminal para um teste mais efetivo (ex: python3 -m http.server 8080)")
    http_exploiter_local = HTTPExploiter(target_host="localhost", port=8080)
    results_local = http_exploiter_local.check_common_vulnerabilities()
    if results_local:
        print("\nVulnerabilidades HTTP encontradas (localhost:8080):")
        for vuln in results_local:
            print(json.dumps(vuln, indent=2))
    
    # print("\n--- Testando HTTPExploiter com scanme.nmap.org ---")
    # results_scanme = http_exploiter.check_common_vulnerabilities()
    # if results_scanme:
    #     print("\nVulnerabilidades HTTP encontradas (scanme.nmap.org):")
    #     for vuln in results_scanme:
    #         print(json.dumps(vuln, indent=2))

    # print("\n--- Testando HTTPExploiter com nmap.org (HTTPS) ---")
    # results_nmap_ssl = http_exploiter_ssl.check_common_vulnerabilities()
    # if results_nmap_ssl:
    #     print("\nVulnerabilidades HTTPS encontradas (nmap.org):")
    #     for vuln in results_nmap_ssl:
    #         print(json.dumps(vuln, indent=2))

    print("\nTestes do HTTPExploiter concluídos.")
    # print("Não se esqueça de parar o servidor HTTP local se você o iniciou.")

